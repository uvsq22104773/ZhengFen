[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/b74Fzo1b)
= Jeu de cartes Zheng Fen

.Composition du groupe (√† compl√©ter)
--
* MACHE, Ethan, 22101464, uvsq22101464
* JOLY, Th√©o, 22104773, uvsq22104773
* TURMEL, Th√©otime, 22300408, uvsq22300408
* SOUMET, Quentin, 22405981, 1Cavalier
--

L'objet de ce mini-projet est de d√©velopper le jeu de carte https://boardgamegeek.com/boardgame/70451/zheng-fen[zheng-fen] qui doit fonctionner en mode ligne de commande.
La r√®gle du jeu est disponible dans la https://boardgamegeek.com/filepage/205610/regles-en-francais-plus-aide-de-jeu[section _Files_] du site pr√©c√©dent.
Cette derni√®re est une traduction fran√ßaise de la page https://www.pagat.com/climbing/zhengfen.html[Zheng Fen (Êå£ÂàÜ)].
Ce jeu comporte de nombreuses variantes (https://www.pagat.com/climbing/doudizhu.html[Dou Dizhu (ÊñóÂú∞‰∏ª)], https://boardgamegeek.com/boardgame/215/tichu[Tichu]).

[IMPORTANT]
====
* **L'objectif de ce projet est de travailler la conception objet**. Donc, plus que les fonctionnalit√©s, vous pr√™terez une attention particuli√®re aux choix de conception qui devront √™tre argument√©s.
* Vous devrez respecter les contraintes techniques et fonctionnelles mentionn√©es ci-dessous.
* L'usage de biblioth√®ques tierces est autoris√©.
* Ce qui n'est pas impos√© par le sujet est laiss√© √† votre libre interpr√©tation.
====

== Contraintes techniques
* Ce mini-projet est √† r√©aliser en Java par groupe de 4 √©tudiants (3 ou 5 possibles avec accord de l'enseignant).
  - les √©tudiants doivent coop√©rer √† travers un m√™me git (celui cr√©√© par _github classroom_).
  Les contributions des participants (_commits_) doivent √™tre √©quilibr√©es.
* Il devra comporter une documentation dans ce fichier (cf. ci-dessous).
  - La documentation devra d√©crire l'usage de l'application (_manuel utilisateur_) ainsi que la conception du jeu (_manuel technique_).
    En particulier, les choix de conception devront √™tre document√©s.
* Vous utiliserez `git` en effectuant des commits r√©guliers d√©crits par des messages informatifs.
L'usage des branches est √©galement exig√©, attestant ainsi de votre collaboration au sein du groupe.
La version finale de votre projet devra se trouver dans la branche `main`.
* La version de Java √† utiliser est la https://adoptium.net/[version 17] (ou plus r√©cente).
* Le _build_ sera assur√© par _Maven_ et plus pr√©cis√©ment _Maven wrapper_ (d√©j√† int√©gr√© dans le projet).
Aucune manipulation en dehors de Maven ne devra √™tre n√©cessaire pour la compilation.
* Le projet devra respecter les r√®gles de codage Google (v√©rification par `checkstyle` d√©j√† int√©gr√© dans le projet).
* Des tests unitaires https://junit.org/junit5/docs/current/user-guide/[JUnit 5] devront √™tre disponibles pour une part significative des m√©thodes d√©velopp√©es.
* Un outil de https://fr.wikipedia.org/wiki/Couverture_de_code[_Code Coverage_] devra √™tre int√©gr√© au _build_
* Les fonctionnalit√©s du langage Java devront √™tre utilis√©es au mieux (POO, exceptions, librairie de collections, I/O, ‚Ä¶).
* L'application devra pouvoir √™tre ex√©cut√©e √† partir d'un `jar` incluant toutes les d√©pendances.
* L'application fonctionnera dans un terminal (pas d'interface graphique).

== Description fonctionnelle
L'application doit permettre de jouer de 0 √† 4 joueurs humains, i.e. de z√©ro √† quatre adversaires virtuels d√©nomm√©s dans la suite _Joueurs Virtuels_ (**JV**).
Chaque JV joue grace √† un _Moteur de Jeu_ (**MJ**) mod√©lis√© par une classe de votre programme.
Un MJ peut appliquer une strat√©gie basique, ou bien jouer √† l'aide de strat√©gies plus sophistiqu√©es.
Bien entendu, l'application doit g√©rer l'encha√Ænement des manches{empty}footnote:[Une manche se termine quand il ne reste des cartes qu'√† un seul joueur (cf. la r√®gle du jeu).] et les d√©comptes des points jusqu'√† la fin du jeu{empty}footnote:[Le jeu se termine lorsqu'un joueur atteint ou d√©passe un certain nombre de points (500 en g√©n√©ral).].

=== Interface de l'application
L'interface textuelle devra

* visualiser les actions de chaque joueur par des messages textuels clairs et concis (par exemple, "JV1: üÇÆ, üÇæ, üÉé, üÉà, üÉò" ou "JV1: K(SHD), 8(DC)").
  - o√π les valeurs et les couleurs des cartes sont donn√©es par leurs initiales en anglais (**K**ing = roi, **Q**ueen = dame, **J**ack = valet, **S**pade = pique, **H**eart = c≈ìur, **D**iamond = carreau et **C**lub = tr√®fle).
* afficher chaque joueur et ses messages dans une couleur distincte.
* valider les saisies des joueurs humains
  - pour saisir une combinaison, le joueur utilisera une syntaxe du type `<Valeur>(<couleur1><couleur2>)` (par exemple "K(SHD), Q(DC)").
* afficher le nombre de cartes de chaque joueur, mais pas les valeurs de ses cartes (sauf en mode d√©bogage).
* toujours afficher les cartes ordonn√©es du plus fort au plus faible et pique (_Spade_) avant c≈ìur (_Heart_) avant carreau (_Diamond_) avant tr√®fle (_Club_).
* afficher un message clair pour les actions effectu√©es par l'application.

=== Contraintes √† respecter
* Un joueur peu d√©cider d'abandonner. 
C'est un √©v√©nement rare (surtout chez les JV), mais possible.
* L'historique d'une partie sera m√©moris√©e dans une collection stock√©e dans un fichier.
  - il sera donc possible de rejouer une partie ou d'afficher le d√©roul√© d'une partie
* Vous devez impl√©menter un MJ appliquant une strat√©gie triviale.
Le MJ se d√©barrasse de ses cartes au fur et √† mesure sans aucun assemblage.
* Vous devez √©galement impl√©menter au moins un MJ qui joue de mani√®re plus sophistiqu√©e.
* Un mode d√©bogage permettra de jouer √† jeux ouverts.
* Le MJ associ√© √† chaque JV doit pouvoir √™tre modifi√©.
* Une interface de configuration permettra de modifier les param√®tres du jeu (variantes, nombre de points pour gagner, MJ √† utiliser, ‚Ä¶)

== R√©f√©rences
* https://github.com/lyudaio/jcards[jCards] - A Lightweight Java Library for manipulating Playing Cards
* http://fusesource.github.io/jansi/[JAnsi] - Gestion des couleur dans un terminal
* https://github.com/jline/jline3[JLine] - Gestion des saisies

== Manuel utilisateur (√† compl√©ter)

=== Comment configurer et d√©marrer une partie ? 
Lors de l'√©xecution du programme il est possible d'acceder aux options dans lesquelles il est possible de :
* modifier le nombre de joueurs
* modifier le nombre d'ia
* modifier la difficult√©s des ia
* modifier le nombre de points pour la victoire
* activer ou d√©sactiver l'utilisation des jokers
* activer ou d√©sactiver des combinaisons particuli√®res
* activer le mode d√©bogage

=== Quelle syntaxe utiliser pour jouer une combinaison de carte ?
Pour jouer des cartes on utilise cette syntaxe : Valeur(couleur1couleur2) par exemple K(HS) pour roi de coeur + roi de pique ou alors 3(S) JK(G) 5(S) JK(P) 7(S) pour la suite 3, grand joker, 5, petit joker, 7.

=== Quelles autres actions sont disponibles ?
il est possible de passer son tour, d'abandonner la partie.

=== Quelles strat√©gies utilisent les diff√©rents MJ ?
* Le MJ normal se d√©barrasse de sa plus petite combinaison possible et si il commence alors il joue sa plus petite carte seule.
* Le MJ expert peut jouer la 5 combinaisons diff√©rentes en les g√©n√©rant de mani√®re al√©atoire, jusqu'√† trouver une combinaison pouvant √™tre jou√©e l√©galement ou jusqu'√† ce que sa limite d'essais soit d√©pass√©e.

=== Quelles √©volutions peut-on envisager ?
* Un moyen plus efficace de trouver une combinaison jouable et la possibilit√© de choisir une combinaison de mani√®re √† ne pas se retrouver avec des cartes uniques difficiles √† placer.

== Manuel technique
=== Compiler le projet
.Sous Linux
----
$ JAVA_HOME=/usr/lib/jvm/java-21-openjdk-amd64/ ./mvnw package
----

.Sous Windows
----
> mvnw.cmd package
----

=== Ex√©cuter l'application
----
$ java -jar target/zhengfen-1.0.jar
----

.√Ä compl√©ter

=== Comment consulter le rapport de couverture de code par les tests ?
Pour consulter le rapport de couverture effectu√© avec Jacoco il suffit de faire :
----
$ start target\site\jacoco\index.html
----

=== Quelles biblioth√®ques ont √©t√© utilis√©es et pourquoi ?
Nous n'avons pas utilis√© de biblioth√®ques tierces. Nous utilisons les biblioth√®ques de Collection de java pour les Listes et les Streams.

=== Quel est le r√¥le des diff√©rentes classes ?
On suit le pattern MVC donc les classes dans VUE g√®rent l'affichage, les classes dans Controller g√®rent les diff√©rentes logiques (le d√©roulement de la partie, etc...) et les classes dans Mod√®le repr√©sentent les diff√©rents structures de donn√©es.

=== Quels choix de conception (principes, patterns, ‚Ä¶) ont √©t√© faits et pourquoi ?
Nous avons utilis√© des abstractions par interfaces pour essayer d'avoir le moins de d√©pendance possible entre les classes. Nous avons utilis√© le design MVC pour l'ensemble du projet.
Nous utilisons le pattern factory pour cr√©er les combinaisons, un pattern visitor pour sugg√©rer des coups √† l'IA selon son niveau et des pattern singleton dans diff√©retnes classes.
En plus les principes SOLID on √©t√© appliqu√© :

* SRP, chaque classe √† un seul objectif notamment AffichageMainVisible, PaquetDeCartes ou OptionManager. 
* OCP, il est tr√®s facilement possible de rajouter de nouvelles combinaisons/strat√©gie d'ia sans avoir besoin de modifier les autres.
* LSP, les sous-classes peuvent √™tre utilis√©es en remplacement de leurs superclasses sans provoquer d‚Äôeffets ind√©sirables. Par exemple, JoueurHumain et JoueurIA sont utilis√©es comme des instances de la classe Joueur sans perturber le comportement du programme.

* ISP, les interfaces sont con√ßues pour ne comporter que les m√©thodes n√©cessaires. Par exemple, StrategieJeu, ComposantAffichage, et Menu sont des interfaces simples et sp√©cifiques.
* DIP, le code d√©pend d‚Äôinterfaces et non d'impl√©mentations concr√®tes, par exemple Joueur, CombinaisonInterface, StrategieJeu sont inject√©s partout.

=== Quels traitements sont r√©alis√©s pour g√©rer une commande saisie par l'utilisateur ? Donnez un exemple.

Lorsqu'un joueur saisit une commande dans le terminal, celle-ci est lue sous forme de cha√Æne de caract√®res via une instance de `Scanner` (encapsul√©e ici dans un singleton `InputManager`).  
Le syst√®me commence par v√©rifier s'il s'agit d'une commande sp√©ciale (`pass`, `abandon`, `stop`, `?`). Si ce n‚Äôest pas le cas, il tente d‚Äôinterpr√©ter la saisie comme une ou plusieurs cartes.

Par exemple, si l'utilisateur entre `3(HCDS)`, la cha√Æne est transmise √† une m√©thode de parsing (`InputToCartes.inputToCartes`), qui :

* d√©tecte la valeur (`3`)
* extrait les couleurs (`H`, `C`, `D`, `S`)
* g√©n√®re une liste d‚Äôobjets `Carte` correspondants
* tente ensuite de construire une combinaison valide √† partir de ces cartes.

Si la combinaison est valide, elle est envoy√©e au contr√¥leur (`PliController`) qui l'accepte ou la refuse selon le contexte de jeu.

=== Quelles am√©liorations peut-on envisager ?

Plusieurs am√©liorations sont envisageables :

- Ajouter une **aide contextuelle dynamique** : afficher des suggestions de coups valides en fonction de la main et de la combinaison en cours.
- Permettre une **correction automatique** de certaines erreurs de syntaxe (`3HCDS` au lieu de `3(HCDS)`).
- Introduire un syst√®me de **commande avec confirmation**, pour √©viter les mauvaises manipulations (`"√ätes-vous s√ªr de vouloir abandonner ?"`)
- Ajouter des **tests d‚Äôaccessibilit√© ou de compatibilit√© terminal** (couleurs, unicode).
- Permettre des commandes personnalis√©es par l'utilisateur (alias ou raccourcis).

- Ajouter un **syst√®me de sauvegarde automatique** pour les parties en cours.
- Utiliser plus d'interfaces, notamment pour Carte dont tout le projet est actuellement d√©pendant.

